\documentclass[a4paper, 10pt, twoside]{article}

\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish, es-ucroman, es-noquoting]{babel}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage{float}
\usepackage{enumitem} % Provee macro \setlist
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{xspace}
\usepackage{qtree}
\usepackage[toc, page]{appendix}


%%%%%%%%%% Constantes - Inicio %%%%%%%%%%
\newcommand{\titulo}{Trabajo Práctico 1}
\newcommand{\materia}{Teoría de Lenguajes}
\newcommand{\integrantes}{Allocati · Izcovich · Vita}
\newcommand{\cuatrimestre}{Primer Cuatrimestre de 2015}
%%%%%%%%%% Constantes - Fin %%%%%%%%%%


%%%%%%%%%% Configuración de Fancyhdr - Inicio %%%%%%%%%%
\pagestyle{fancy}
\thispagestyle{fancy}
\lhead{\titulo\ · \materia}
\rhead{\integrantes}
\renewcommand{\footrulewidth}{0.4pt}
\cfoot{\thepage /\pageref{LastPage}}

\fancypagestyle{caratula} {
   \fancyhf{}
   \cfoot{\thepage /\pageref{LastPage}}
   \renewcommand{\headrulewidth}{0pt}
   \renewcommand{\footrulewidth}{0pt}
}
%%%%%%%%%% Configuración de Fancyhdr - Fin %%%%%%%%%%


%%%%%%%%%% Miscelánea - Inicio %%%%%%%%%%
% Evita que el documento se estire verticalmente para ocupar el espacio vacío
% en cada página.
\raggedbottom

% Separación entre párrafos.
\setlength{\parskip}{0.5em}

% Separación entre elementos de listas.
\setlist{itemsep=0.5em}

% Asigna la traducción de la palabra 'Appendices'.
\renewcommand{\appendixtocname}{Apéndices}
\renewcommand{\appendixpagename}{Apéndices}

\newcommand{\grafico}[1]{
  \begin{center}
    \includegraphics[height=10cm]{#1}
  \end{center}
}


%%%%%%%%%% Miscelánea - Fin %%%%%%%%%%

\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Carátula                                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\thispagestyle{caratula}

\begin{center}

\includegraphics[height=2cm]{DC.png} 
\hfill
\includegraphics[height=2cm]{UBA.jpg} 

\vspace{2cm}

Departamento de Computación,\\
Facultad de Ciencias Exactas y Naturales,\\
Universidad de Buenos Aires

\vspace{4cm}

\begin{Huge}
\titulo
\end{Huge}

\vspace{0.5cm}

\begin{Large}
\materia
\end{Large}

\vspace{1cm}

\cuatrimestre

\vspace{4cm}

\begin{tabular}{|c|c|c|}
\hline
Apellido y Nombre & LU & E-mail\\
\hline
Allocati, Federico  & 682/11 & fede.allocati@gmail.com\\
Izcovich, Sabrina & 550/11 & sizcovich@gmail.com\\
Vita, Sebastián & 149/11 & sebastian\_vita@yahoo.com.ar\\
\hline
\end{tabular}

\end{center}

\newpage

\tableofcontents

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Introducción                                                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introducción}
En el siguiente trabajo práctico, debimos diseñar e implementar un programa que permita la construcción y ejecución de Autómatas Finitos Determinísticos. Para ello, fue necesario implementar un parser capaz de generar un autómata finito a partir de un archivo con su expresión regular.\\
Por otro lado, se nos solicitó determinizar el autómata generado, en el caso en el que no lo fuera. Por otra parte, debimos implementar la minimización de autómatas para aplicarlo al autómata obtenido.

Por último, debimos programar ciertas funciones adicionales. Éstas fueron:
\begin{itemize}
\item Dado un autómata finito determinístico y una cadena, definir si esta última pertenece al lenguaje del autómata.
\item Dado un autómata finito determinístico, generar su grafo correspondiente en lenguaje DOT.
\item Dados dos autómatas determinísticos, devolver la el autómata de intersección mínimo.
\item Dado un autómata finito determinístico, obtener su complemento mínimo.
\item Dados dos autómatas determinísticos, verificar su equivalencia.
\end{itemize} 

El lenguaje utilizado fue Python.
En lo que sigue, explicaremos detalles de la implementación.
\newpage
\section{Implementación}

En primer lugar, debimos definir los autómatas. Para esto, creamos una clase para los autómatas determinísticos y otra para el caso de autómatas no determinísticos.\\
\newline
En un principio, se definió la clase \textit{AutomataDet} con su descripción correspondiente $<Q, \Sigma, \delta, S_0, F>$. El conjunto de estados, el alfabeto y el conjunto de estados finales fueron definidos con un Set\footnote{https://docs.python.org/2/library/sets.html}. La función de transición fue representada con un diccionario\footnote{https://docs.python.org/2/tutorial/datastructures.html\#dictionaries}.\\
\newline
En la clase, definimos las funciones necesarias para la realización de lo requerido. Entre ellas, se encuentran \textit{setearInicial} (que configura a un estado como el inicial), \textit{agregarEstado}, \textit{agregarFinal}, \textit{setearArista}, entre otras.\\
\newline
Luego, definimos la clase \textit{AutomataNoDet} con los mismos compuestos que la anterior, pero con el agregado de \textit{lambda} en $\Sigma$. Las funciones implementadas en la clase fueron las mismas que para el caso de determinísticos.\\
\newline
Para mejorar la claridad de los resultados, utilizamos la función \textit{renombrarEstados} para lograr uniformidad en los autómatas obtenidos. Para esto, se utilizó una cola\footnote{https://docs.python.org/2/library/queue.html} para recorrer los estados y renombrarlos paulatinamente a través del algoritmo BFS\footnote{http://web.cse.ohio-state.edu/~gurari/course/cis680/cis680Ch14.html\#QQ1-46-92}.

\subsection{De regex a autómata}
Para crear un autómata a partir de una expresión regular, implementamos un algoritmo capaz de recorrer cada línea y determinar si contiene ${CONCAT}$, ${OR}$, ${STAR}$, ${PLUS}$, ${OPT}$ o $\\t$. En cada caso, se llama a la función constructora correspondiente, definida en \textit{construirNoDet.py}.\\
\newline
Para diferenciar los estados provenientes de uno u otro autómata, agregamos un ``-1'' o un ``-2'' a cada estado, dependiendo de su autómata de origen.

\subsection{Determinizar}
Para la realización de una función capaz de transformar un autómata no determinístico en uno determinístico implementamos el algoritmo visto en clase. Para esto, utilizamos las funciones \textit{mover} y \textit{clausura lambda}:
\begin{itemize}
\item La función \textit{mover} toma un símbolo y un conjunto de estados. En primer lugar, crea un conjunto con todos los estados a los que se llega partiendo de un estado del conjunto inicial y moviéndose por una transición del símbolo pasado por parámetro. Luego, calcula la \textit{clausuraLambda} de cada uno de los estados del conjunto resultante.
\item La función \textit{clausuraLambda} devuelve todos los estados a los que se puede llegar partiendo de uno determinado y moviéndose por transiciones \textit{lambda}. Esto es:
Clausura-$\lambda$ (k) = \{r $\in$ Q $| \exists$ q $\in$ k $\land$ (q,$\lambda$) $\vdash^{*}$ (r,$\lambda$)\}
\end{itemize}

\subsection{Minimizar}
En la función de minimizar, se implementó el algoritmo visto en clase. Para eso, se definieron los diccionarios \textit{ultimasClases} y \textit{ejes}.\\
\newline
Para todos los estados, se los guardó como 'q1' en el caso en el que fueran finales y como 'q0' en el caso contrario.\\
Luego, se declaró un diccionario \textit{tabla} para almacenar la transición de \textit{ultimasClases} en cada estado y para cada símbolo del autómata.\\
\newline
Más tarde, se recorren nuevamente los estados del autómata y se convierten los valores de la tabla a un string del tipo ``q0-q1-q2-q1'' a través de un $join$\footnote{$http://www.tutorialspoint.com/python/string\_join.htm$} de los valores de \textit{tabla} de ese estado, para luego poder hashear.\\
\newline
Luego de verificar que el estado no esté almacenado, se lo agrega al diccionario \textit{clases}, y su valor en \textit{tabla} es agregado en \textit{ejes}. Dichos estados son, más adelante, agregados como Estados del nuevo autómata generado, al igual que los símbolos obtenidos con sus aristas correspondientes declaradas en \textit{ejes}.\\
\newline
En el caso en el que se llegue al estado inicial o a alguno final, se los define como tales en \textit{claseInicial} o \textit{claseFinal} respectivamente.\\
\newline
De este modo, se configuran los estados del nuevo autómata minimal.

\subsection{Cadena pertenece al lenguaje de un autómata}
Dicha función se definió dentro de la clase \textit{AutomataDet}. La misma se limita a recorrer los símbolos de la cadena a través de las transiciones y si logra llegar a todos, devuelve \textbf{True}, caso contrario, devuelve \textbf{False}.

\subsection{Generación del autómata en lenguaje DOT}
La generación del autómata en lenguaje DOT se desarrolló a partir de la bibliografía propuesta por la cátedra. Para ello, la función elaborada recorre los símbolos pertenecientes a la transición de cada estado y almacena cada transición en el caso en el que pertenezca al diccionario \textit{ejes}, definido inicialmente. Caso contrario, almacena el símbolo en un Set.\\
\newline
Luego, escribe en $archivo\_dot$ los caracteres correspondientes al lenguaje DOT.

\subsection{Intersección de autómatas}
Para la intersección de autómatas, utilizamos la siguiente definición: Sean A y B dos autómatas. Los estados de la intersección van a ser los pares de los estados de A y B, o sea Estados$(A \cap B)$ = Estados(A)$x$Estados(B). El estado inicial será ($q0_A$,$q0_B$) y los finales $F(A\cap B)=F(A)xF(B)$. Finalmente, la función de transición $\lambda(A\cap B)$ se define como sigue: para cualquier $\alpha \in \Sigma$ y $p_1, p_2\ \in$ Estados(A), $q_1, q_2\ \in$ Estados(B):

$$\langle p_1,q_1\rangle \xrightarrow[A\cap B]{\alpha}\langle p_2,q_2\rangle \ sii\ p_1\xrightarrow[A]{\alpha}p_2\ y\ q_1\xrightarrow[B]{\alpha}q_2$$

Para implementar esto, comenzamos definiendo un nuevo autómata con $\Sigma$ = $\Sigma (automata1)$ U $\Sigma (automata2)$. Luego, se definieron los estados del nuevo autómata como la combinación de todos los estados del autómata1 con todos los del autómata2.\\
\newline
Por otro lado, se configuraron las aristas con las transiciones correspondientes al autómata1 unidas con las correspondientes al autómata 2, para la respectiva combinación de estados.\\
\newline
Por otra parte, se agregaron los estados ``q1-q2'' como finales cuando ``q1'' es final de automata1 y ``q2'' es final de automata2.\\
Por último, se dispuso la asignación de las transiciones faltantes al estado trampa. Para esto, se recorrieron los estados y, en el caso en el que alguno de ellos no tuviera transición a otro, se lo asigna al \textit{trampa}.

\subsection{Complemento de un autómata}
El complemento se realizó creando un nuevo autómata con todos los estados del autómata original. En el caso en el que $\delta$(q, s) no estuviera definido para algún $q$ perteneciente a $Q$ y algún $s$ perteneciente a $\Sigma$, se agrega un estado $Trampa$, y se define $\delta$(q,s) para cada uno de estos pares estado-símbolo como $Trampa$.\\
\newline
En el caso de los estados finales, se definió como tales a los que no eran finales en el autómata original, incluyendo al trampa si es agregado al nuevo autómata.\\
\newline
Luego, se configuran las aristas faltantes al estados trampa.

\subsection{Equivalencia de autómatas}
Para verificar la equivalencia de autómatas, se realiza, en primer lugar, la intersección entre automata1 y complemento de automata2. Por definición de conjuntos, si automata1 y automata2 reconocen los mismos mensajes, esta intersección debería dar vacía. Entonces, verificamos que el lenguaje reconocido por este nuevo automata sea vacío.\\
\newline
Para esto último, elaboramos la función \textit{noAceptaNingunaCadena} que utiliza el algoritmos DFS. Para eso, se recurrió a las estructuras $Set$ y $deque$\footnote{https://docs.python.org/2/library/collections.html\#collections.deque} para recorrer un autómata. Los estados se extraen con la función $pop$ y, para cada caso, se verifica si el mismo pertenece a los estados finales. Si esto ocurre se termina de recorrer y se devuelve False, caso contrario se agrega el estado al $Set$.\\
\newline
Por último, se recorre cada símbolo del autómada y si no fue visitado se lo agrega a la $deque$.\\
\newline
Finalmente, se devuelve True.

\newpage
\section{Conclusión}
Luego de haber implementado el pasaje de Regex a Autómata Finito, de Autómata Finito No Determinístico a Autómata Finito Determinístico y de AFD a Autómata Mínimal en Python, podemos concluir que la utilización de Sets y Diccionarios resulta adecuada para la correcta representación de autómatas. Dichas estructuras facilitaron la programación de las funciones de pertenencia, de generación de grafo DOT, de intersección, de complemento, como también de equivalencia, que se resolvió aplicando el algoritmo de DFS.


\end{document}
