\documentclass[a4paper, 10pt, twoside]{article}

\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish, es-ucroman, es-noquoting]{babel}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage{float}
\usepackage{enumitem} % Provee macro \setlist
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{xspace}
\usepackage{qtree}
\usepackage[toc, page]{appendix}


%%%%%%%%%% Constantes - Inicio %%%%%%%%%%
\newcommand{\titulo}{Trabajo Práctico 2}
\newcommand{\materia}{Teoría de Lenguajes}
\newcommand{\integrantes}{Allocati · Izcovich · Vita}
\newcommand{\cuatrimestre}{Primer Cuatrimestre de 2015}
%%%%%%%%%% Constantes - Fin %%%%%%%%%%


%%%%%%%%%% Configuración de Fancyhdr - Inicio %%%%%%%%%%
\pagestyle{fancy}
\thispagestyle{fancy}
\lhead{\titulo\ · \materia}
\rhead{\integrantes}
\renewcommand{\footrulewidth}{0.4pt}
\cfoot{\thepage /\pageref{LastPage}}

\fancypagestyle{caratula} {
   \fancyhf{}
   \cfoot{\thepage /\pageref{LastPage}}
   \renewcommand{\headrulewidth}{0pt}
   \renewcommand{\footrulewidth}{0pt}
}
%%%%%%%%%% Configuración de Fancyhdr - Fin %%%%%%%%%%


%%%%%%%%%% Miscelánea - Inicio %%%%%%%%%%
% Evita que el documento se estire verticalmente para ocupar el espacio vacío
% en cada página.
\raggedbottom

% Separación entre párrafos.
\setlength{\parskip}{0.5em}

% Separación entre elementos de listas.
\setlist{itemsep=0.5em}

% Asigna la traducción de la palabra 'Appendices'.
\renewcommand{\appendixtocname}{Apéndices}
\renewcommand{\appendixpagename}{Apéndices}

\newcommand{\grafico}[1]{
  \begin{center}
    \includegraphics[height=10cm]{#1}
  \end{center}
}


%%%%%%%%%% Miscelánea - Fin %%%%%%%%%%

\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Carátula                                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\thispagestyle{caratula}

\begin{center}

\includegraphics[height=2cm]{DC.png} 
\hfill
\includegraphics[height=2cm]{UBA.jpg} 

\vspace{2cm}

Departamento de Computación,\\
Facultad de Ciencias Exactas y Naturales,\\
Universidad de Buenos Aires

\vspace{4cm}

\begin{Huge}
\titulo
\end{Huge}

\vspace{0.5cm}

\begin{Large}
\materia
\end{Large}

\vspace{1cm}

\cuatrimestre

\vspace{4cm}

\begin{tabular}{|c|c|c|}
\hline
Apellido y Nombre & LU & E-mail\\
\hline
Allocati, Federico  & 682/11 & fede.allocati@gmail.com\\
Izcovich, Sabrina & 550/11 & sizcovich@gmail.com\\
Vita, Sebastián & 149/11 & sebastian\_vita@yahoo.com.ar\\
\hline
\end{tabular}

\end{center}

\newpage

\tableofcontents

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Introducción                                                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introducción}

En el siguiente trabajo práctico, debimos diseñar e implementar un programa que permita generar un archivo de audio MIDI a partir de una pieza musical escrita en un lenguaje llamado $Musileng$. Para ello, debimos diseñar una gramática específica para ese lenguaje y posteriormente, implementar un parser que genere un código intermedio a partir de dicha gramática. Una vez obtenido el código intermedio, este se transformó en un archivo de texto con un determinado formato que sirve de entrada para un programa que es capaz de generar archivos MIDI.

En lo que sigue, explicaremos detalles de la implementación.
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Implementación                                                            %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementación}
Como vimos anteriormente, el problema se puede dividir en dos:
\begin{itemize}
 \item Transformar el código escrito en lenguaje $Musileng$ a una gramática mediante el uso de un parser.

 \item Transformar lo obtenido por el parser en un archivo en formato SMF $(Standard\ Midi\ File)$ \footnote{http://www.midi.org/aboutmidi/tut\_midifiles.php}

\end{itemize}

\subsection{Parser}
Para la creación del parser, definimos un lexer \footnote{lexer\_rules.py} que se encarga de traducir el lenguaje $Musileng$ a una secuencia de $tokens$. Para ello, se eliminan todos los comentarios del archivo de entrada y se detectan los posibles errores léxicos del mismo.

Las expresiones regulares utilizadas para distinguir los tokens son las siguientes: 
\begin{center}
$
\begin{array}{l}
      $num$ \rightarrow\  $[0-9][0-9]*$ \\

  	  $tone$\ \rightarrow\ $[a-z][a-z]*(+ $\mid$ -)$\\

  	  $fig$\ \rightarrow\ $[a-z][a-z]*(.)$\\
\end{array}
$
\end{center}

El resto de los tokens, se distinguen utilizando la siguiente expresión regular [\_a-zA-Z][\_a-zA-Z0-9]*

Una vez obtenida la secuencia de tokens, se define la siguiente gramática\footnote{parser\_rules.py} $G\ = <V_n,\ V_t,\ P,\ S>$. En donde: 
\begin{itemize}
\item $V\_n = \{song\_declaration,\ tempo,\ time\_signature,\ const\_dict,\ voice\_list,\ num\_or\_const\_id,\ voice\_content,\\ \ bar\_or\_repeat,\ bar\_content\}$

\item $V\_t = \{tempo,\ bar,\ voice,\ repeat,\ note,\ silence,\ fig,\ tone,\ num,\ const,\ const\_id,\  numeral,\ slash,\ equals,\\ semicolon,\ lparen,\ rparen,\ lbrace,\ rbrace,\ comma\}$

\item 
\begin{equation*}
  P = \left\lbrace
  \begin{array}{l}
      $song\_declaration$ \rightarrow\  $tempo\ time\_signature\ const\_dict\ voice\_list$ \\

  $tempo$\ \rightarrow\ numeral\ tempo\ fig\ num\\

  $time\_signature$\ \rightarrow\ numeral\ bar\ num\ slash\ num\\

  $const\_dict$\ \rightarrow\ const\ const\_id\ equals\ num\ semicolon\ $const\_dict$ \mid\ \lambda\\

  $voice\_list$\ \rightarrow\ voice\ lparen\ $num\_or\_const\_id$\ rparen\ lbrace\ $voice\_content$\ rbrace\ $voice\_list$ \mid\ \lambda\\

  $num\_or\_const\_id$\ \rightarrow\ num\ \mid\ const\_id\\

  $voice\_content$\ \rightarrow\ $bar\_or\_repeat\ voice\_content$\ \mid\ \lambda\\

  $bar\_or\_repeat$\ \rightarrow\ bar\ lbrace\ $bar\_content$\ rbrace\ \mid\ 
 \\ \-\hspace{2.5cm}\ repeat\ lparen\ $num\_or\_const\_id$\ rparen\ lbrace\ $voice\_content$\ rbrace\\

  $bar\_content$\ \rightarrow\ note\ lparen\ tone\ comma\ $num\_or\_const\_id$\ comma\ fig\ rparen\ semicolon\ \mid\ 
 \\ \-\hspace{2.2cm}\ silence\ lparen\ fig\ rparen\ semicolon\ \mid
 \\ \-\hspace{2.2cm}\ note\ lparen\ tone\ comma\ $num\_or\_const\_id$ comma\ fig\ rparen\ semicolon\ $bar\_content$\mid
 \\ \-\hspace{2.2cm}\ silence\ lparen\ fig\ rparen\ semicolon\ $bar\_content$

  \end{array}
  \right.
\end{equation*}
\item $S = song\_declaration$

\end{itemize}

Con la gramática previamente definida se crea un objeto $song$ el cual contiene el tempo, el compás y la lista de voces. En $tempo$, se verifica que su duración sea mayor a un segundo. Si esto ocurre, entonces se almacena tanto la figura como la cantidad de veces que ésta aparece en un minuto. En el caso del $compas$ se comprueba que la cantidad de pulsos sea mayor a 1 y que la duración de dichos pulsos pertenezca a una figura válida. Por último, se encuentra la $lista de voces$. 

Cada voz posee un conjunto de compases y Repeats. Dichos compaces están conformados por una lista de notas y silencios. Por otro lado, los $Repeats$ se encargan de repetir un compás más de una vez.

\subsection{Traducción a MIDI}
Una vez obtenida la salida del parser se procede a crear un archivo el cual puede ser interpretado por un generador de archivos MIDI como por ejemplo $midicomp$ \footnote{http://freepats.zenvoid.org/tools/midicomp/}

La entrada al programa $midicomp$ es un archivo que consta de dos partes. En la primera, se crea el encabezado del archivo. En éste se declara la cantidad de tracks que contiene, el compás de los mismos y el tempo el cual indica cuantos microsegundos dura una negra. Como el tempo en nuestro programa se mide por minuto y utilizando cualquier nota, no sólo la negra, utilizamos la siguiente fórmula para realizar la conversión:
$\frac{1000000\ *\ 60\ *\ figura}{4\ *\ n}$

En la segunda parte, se define cada uno de los tracks. Cada track se corresponde con una voz y se le asigna un canal único. Para cada uno de éstos, se genera un encabezado conteniendo el nombre del track, el instrumento que interpreta y el canal en el que está. Luego, se declaran dos lineas para coda una de las notas de los compaces. Una para encenderla y la otra para apagarla. El formato utilizado es el siguiente:

\begin{center} 
COMPAS:PULSO:CLICK STATUS ch=CANAL note=NOTA vol=VOL
\end{center}

en donde $PULSO:CLICK$ se calcula en base a la duración de cada nota y al orden de la misma dentro del compás siendo 384 la cantidad máxima de clicks por pulso. Para poder calcular qué $PULSO:CLICK$ le corresponde a cada nota, se utilizaron las fórmulas provistas por la cátedra.

En el caso de los silencios, se calculó el $PULSO:CLICK$ pero no se escribío la línea $COMPAS:PULSO:CLICK\ STATUS\ ch=CANAL\ note=NOTA\ vol=VOL$ dado que no resultó necesario.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Test                                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Test}
Implementamos una serie de tests para corroborar el correcto funcionamiento de nuestro programa. Los errores que se verificaron fueron los siguientes:

\begin{itemize}
\item Más de 16 voces
\item Ninguna voz
\item Un compás con duración mayor a la especificada
\item Un compás con duración menor a la especificada
\item Un compás vacío 
\item Un Repetir vacío
\item Una voz vacía 
\item Un compás que usa una constante no declarada
\item Un número de instrumento fuera de rango
\item Un Repetir con parámetro 0

\end{itemize}
demás de estos tests, se generaron otros tres para comprobar que el resultado del programa fuera el deseado. El primero de ellos es el que nos proveyó la cátedra. El segundo, es el Vals de Amélie, que está interpretado por un Grand Piano. Por último, generamos la canción del Padrino interpretada con dos acordiones y una guitarra.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Ejecución                                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Ejecución}
El programa se ejecuta mediante el comando $python\ parser.py\ archivo\_entrada\ [archivo\_salida]$ y genera un archivo en formato MIDI. En el caso en el que no se provea un archivo de salida, se mostrará el resultado en la salida estandar. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Conclusión                                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusión}

Luego de haber realizado toda la implementación en Python, llegamos a la conclusión de que es un lenguaje muy ameno para la construccion de parsers. Esto se debe a que el generador de parsers $ply$ es muy sencillo de usar.

\end{document}
