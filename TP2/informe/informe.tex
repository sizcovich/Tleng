\documentclass[a4paper, 10pt, twoside]{article}

\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish, es-ucroman, es-noquoting]{babel}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage{graphicx}
\usepackage{float}
\usepackage{enumitem} % Provee macro \setlist
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{xspace}
\usepackage{qtree}
\usepackage[toc, page]{appendix}


%%%%%%%%%% Constantes - Inicio %%%%%%%%%%
\newcommand{\titulo}{Trabajo Práctico 2}
\newcommand{\materia}{Teoría de Lenguajes}
\newcommand{\integrantes}{Allocati · Izcovich · Vita}
\newcommand{\cuatrimestre}{Primer Cuatrimestre de 2015}
%%%%%%%%%% Constantes - Fin %%%%%%%%%%


%%%%%%%%%% Configuración de Fancyhdr - Inicio %%%%%%%%%%
\pagestyle{fancy}
\thispagestyle{fancy}
\lhead{\titulo\ · \materia}
\rhead{\integrantes}
\renewcommand{\footrulewidth}{0.4pt}
\cfoot{\thepage /\pageref{LastPage}}

\fancypagestyle{caratula} {
   \fancyhf{}
   \cfoot{\thepage /\pageref{LastPage}}
   \renewcommand{\headrulewidth}{0pt}
   \renewcommand{\footrulewidth}{0pt}
}
%%%%%%%%%% Configuración de Fancyhdr - Fin %%%%%%%%%%


%%%%%%%%%% Miscelánea - Inicio %%%%%%%%%%
% Evita que el documento se estire verticalmente para ocupar el espacio vacío
% en cada página.
\raggedbottom

% Separación entre párrafos.
\setlength{\parskip}{0.5em}

% Separación entre elementos de listas.
\setlist{itemsep=0.5em}

% Asigna la traducción de la palabra 'Appendices'.
\renewcommand{\appendixtocname}{Apéndices}
\renewcommand{\appendixpagename}{Apéndices}

\newcommand{\grafico}[1]{
  \begin{center}
    \includegraphics[height=10cm]{#1}
  \end{center}
}


%%%%%%%%%% Miscelánea - Fin %%%%%%%%%%

\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Carátula                                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\thispagestyle{caratula}

\begin{center}

\includegraphics[height=2cm]{DC.png} 
\hfill
\includegraphics[height=2cm]{UBA.jpg} 

\vspace{2cm}

Departamento de Computación,\\
Facultad de Ciencias Exactas y Naturales,\\
Universidad de Buenos Aires

\vspace{4cm}

\begin{Huge}
\titulo
\end{Huge}

\vspace{0.5cm}

\begin{Large}
\materia
\end{Large}

\vspace{1cm}

\cuatrimestre

\vspace{4cm}

\begin{tabular}{|c|c|c|}
\hline
Apellido y Nombre & LU & E-mail\\
\hline
Allocati, Federico  & 682/11 & fede.allocati@gmail.com\\
Izcovich, Sabrina & 550/11 & sizcovich@gmail.com\\
Vita, Sebastián & 149/11 & sebastian\_vita@yahoo.com.ar\\
\hline
\end{tabular}

\end{center}

\newpage

\tableofcontents

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Introducción                                                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introducción}

En el siguiente trabajo práctico, debimos diseñar e implementar un programa que permita generar un archivo de audio MIDI\footnote{http://www.midi.org/aboutmidi/tut\_midifiles.php} a partir de una pieza musical escrita en un lenguaje llamado $Musileng$. Para ello, debimos diseñar una gramática que reconozca ese lenguaje y posteriormente, implementar un parser que genere un código intermedio a partir de dicha gramática. Una vez obtenido el código intermedio, utilizamos el programa $midicomp$ \footnote{http://freepats.zenvoid.org/tools/midicomp/} para generar el archivo en formato MIDI.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Implementación                                                            %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementación}
\subsection{Gramática}
El primer paso para la definición de nuestra gramática $G\ = <V_n,\ V_t,\ P,\ S>$ fue decidir cuales serían los símbolos terminales de la misma. Luego con esto, definimos los no terminales, y las producciones.

\subsubsection{Terminales - Tokens}

$V\_t = \{tempo,\ bar,\ voice,\ repeat,\ note,\ silence,\ fig,\ tone,\ num,\ const,\ const\_id,\  numeral,\ slash,\ equals,\\ semicolon,\ lparen,\ rparen,\ lbrace,\ rbrace,\ comma\}$

El lexer con sus reglas definidas en lexer\_rules.py se encarga de convertir el archivo de entrada a una secuencia de estos $tokens$ de simbolos terminales.

Las expresiones regulares utilizadas para distinguir los tokens son las siguientes: 
\begin{enumerate}
\item	$[0-9][0-9]* \rightarrow$ se utiliza para transformar numeros en el terminal $num$ \\
\item	$[\_a-zA-Z][\_a-zA-Z0-9]* \rightarrow$ se utiliza para reconocer todas las palabras que comienzen con letras o guión bajo, y sigan con cualquier cantidad de letas, guiones bajos o numeros. Si el valor reconocido es alguna de las palabras reservadas del lenguaje (tempo, compas, voz, repetir, const, nota o silencio), se mapea al token correspondiente ($tempo,\ bar,\ voice,\ repeat,\ const,\ note$ y $silencio$). Si el valor se corresponde con alguna de las figuras (redonda, blanca, negra, corchea, semicorchea, fusa o semifusa), se lo mapea al token $fig$. Si el valor se corresponde con alguna de los tonos (do, re, mi, fa, sol, la o si) se lo mapea al token $tone$. Finalmente, cualquier valor que matchee la expresión regular, y no caiga en ninguno de los casos anteriores, se lo considera como que es un nombre de constante, mapeandoselo al token $const\_id$.
\item $[a-z][a-z]*(\backslash .) \rightarrow$ se utiliza para reconocer las figuras con puntillo. Estas tambien se las mapea al token $fig$. En caso de que el valor no sea una figura, arroja un error de sintaxis.
\item $[a-z][a-z]*(\backslash + \mid \backslash -) \rightarrow$ se utiliza para reconocer las tonalidades con alteraciones. Estas tambien se las mapea al token $tone$. En caso de que el valor no sea un tono, arroja un error de sintaxis.
\end{enumerate}

El resto de los tokens se reconoce buscando directamente el caracter apropiado, como por ejemplo ``\#'' para el token $numeral$, ``;'' para el token $semicolon$, etc.

Finalmente, el lexer tambien se encargar de eliminar los comentarios. Para ello, utiliza la expresión regular $//(.*?)\backslash r?\backslash n$, que matchea todo lo que se encuentra entre dos barras y el fín de linea, y lo ignora.

\subsubsection{No Terminales}
Definimos la siguiente lista de símbolos no terminales:

$V\_n = \{song\_declaration,\ tempo\_declaration,\ time\_signature\_declaration,\ const\_dict,\ voice\_list,\ num\_or\_const\_id,\ voice\_content,\\ \ bar\_or\_repeat,\ bar\_content\}$

El símbolo distinguido será:

$S = song\_declaration$

\subsubsection{Producciones}

Las producciones correspondientes son:

\begin{equation*}
  P = \left\lbrace
  \begin{array}{l}
      $song\_declaration$ \rightarrow\  $tempo\_declaration\ time\_signature\_declaration\ const\_dict\ voice\_list$ \\

  $tempo\_declaration$\ \rightarrow\ numeral\ tempo\ fig\ num\\

  $time\_signature\_declaration$\ \rightarrow\ numeral\ bar\ num\ slash\ num\\

  $const\_dict$\ \rightarrow\ const\ const\_id\ equals\ num\ semicolon\ $const\_dict$ \mid\ \lambda\\

  $voice\_list$\ \rightarrow\ voice\ lparen\ $num\_or\_const\_id$\ rparen\ lbrace\ $voice\_content$\ rbrace\ $voice\_list$ \mid\ \lambda\\

  $num\_or\_const\_id$\ \rightarrow\ num\ \mid\ const\_id\\

  $voice\_content$\ \rightarrow\ $bar\_or\_repeat\ voice\_content$\ \mid\ \lambda\\

  $bar\_or\_repeat$\ \rightarrow\ bar\ lbrace\ $bar\_content$\ rbrace\ \mid\ 
 \\ \-\hspace{2.5cm}\ repeat\ lparen\ $num\_or\_const\_id$\ rparen\ lbrace\ $voice\_content$\ rbrace\\

  $bar\_content$\ \rightarrow\ note\ lparen\ tone\ comma\ $num\_or\_const\_id$\ comma\ fig\ rparen\ semicolon\ \mid\ 
 \\ \-\hspace{2.2cm}\ silence\ lparen\ fig\ rparen\ semicolon\ \mid
 \\ \-\hspace{2.2cm}\ note\ lparen\ tone\ comma\ $num\_or\_const\_id$ comma\ fig\ rparen\ semicolon\ $bar\_content$\mid
 \\ \-\hspace{2.2cm}\ silence\ lparen\ fig\ rparen\ semicolon\ $bar\_content$

  \end{array}
  \right.
\end{equation*}

Aclaramos que tomamos la decisión de que nuestro parser acepte $repetir$ anidados, ya que no nos agregaba mucha complejidad, y si aportaba mayor flexibilidad a la hora de la composición.
Tambien

\subsection{Parser}

Con la gramática previamente definida se crea un objeto $song$ el cual contiene el tempo, el compás y la lista de voces. En $tempo$, se verifica que su duración sea mayor a un segundo. Si esto ocurre, entonces se almacena tanto la figura como la cantidad de veces que ésta aparece en un minuto. En el caso del $compas$ se comprueba que la cantidad de pulsos sea mayor a 1 y que la duración de dichos pulsos pertenezca a una figura válida. Por último, se encuentra la $lista de voces$. 

Cada voz posee un conjunto de compases y Repeats. Dichos compaces están conformados por una lista de notas y silencios. Por otro lado, los $Repeats$ se encargan de repetir un compás más de una vez.

\subsection{Traducción a MIDI}
Una vez obtenida la salida del parser se procede a crear un archivo el cual puede ser interpretado por un generador de archivos MIDI como por ejemplo 

La entrada al programa $midicomp$ es un archivo que consta de dos partes. En la primera, se crea el encabezado del archivo. En éste se declara la cantidad de tracks que contiene, el compás de los mismos y el tempo el cual indica cuantos microsegundos dura una negra. Como el tempo en nuestro programa se mide por minuto y utilizando cualquier nota, no sólo la negra, utilizamos la siguiente fórmula para realizar la conversión:
$\frac{1000000\ *\ 60\ *\ figura}{4\ *\ n}$

En la segunda parte, se define cada uno de los tracks. Cada track se corresponde con una voz y se le asigna un canal único. Para cada uno de éstos, se genera un encabezado conteniendo el nombre del track, el instrumento que interpreta y el canal en el que está. Luego, se declaran dos lineas para coda una de las notas de los compaces. Una para encenderla y la otra para apagarla. El formato utilizado es el siguiente:

\begin{center} 
COMPAS:PULSO:CLICK STATUS ch=CANAL note=NOTA vol=VOL
\end{center}

en donde $PULSO:CLICK$ se calcula en base a la duración de cada nota y al orden de la misma dentro del compás siendo 384 la cantidad máxima de clicks por pulso. Para poder calcular qué $PULSO:CLICK$ le corresponde a cada nota, se utilizaron las fórmulas provistas por la cátedra.

En el caso de los silencios, se calculó el $PULSO:CLICK$ pero no se escribío la línea $COMPAS:PULSO:CLICK\ STATUS\ ch=CANAL\ note=NOTA\ vol=VOL$ dado que no resultó necesario.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Test                                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Test}
Implementamos una serie de tests para corroborar el correcto funcionamiento de nuestro programa. Los errores que se verificaron fueron los siguientes:

\begin{itemize}
\item Más de 16 voces
\item Ninguna voz
\item Un compás con duración mayor a la especificada
\item Un compás con duración menor a la especificada
\item Un compás vacío 
\item Un Repetir vacío
\item Una voz vacía 
\item Un compás que usa una constante no declarada
\item Un número de instrumento fuera de rango
\item Un Repetir con parámetro 0
\item Tempo sin valor
\item Tempo sin figura

\end{itemize}
Además de estos tests, se escribieron otros tres inputs comprobar que el resultado del programa fuera el deseado. El primero de ellos es el que se presentó en el enunciado. El segundo es la melodía de la famosa película ``El Padrino'', en el que probamos varias voces en simultaneo. Por último, escribimos la introducción del Vals de Amélie, un vals en 12 / 8. Aqui probamos la funcionalidad de repetición (tanto anidada como no anidada).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Ejecución                                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Ejecución}
El programa se ejecuta mediante el comando $python\ parser.py\ archivo\_entrada\ [archivo\_salida]$ y genera un archivo en formato MIDI. En el caso en el que no se provea un archivo de salida, se mostrará el resultado en la salida estandar. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Conclusión                                                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusión}

Luego de haber realizado toda la implementación en Python, llegamos a la conclusión de que es un lenguaje muy ameno para la construccion de parsers. Esto se debe a que el generador de parsers $ply$ es muy sencillo de usar.

\end{document}
